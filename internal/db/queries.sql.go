// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
)

const accountByID = `-- name: AccountByID :one
SELECT account_id, account_abbr, account_name, account_active FROM accounts
WHERE account_id = ? LIMIT 1
`

func (q *Queries) AccountByID(ctx context.Context, accountID int64) (Account, error) {
	row := q.db.QueryRowContext(ctx, accountByID, accountID)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.AccountAbbr,
		&i.AccountName,
		&i.AccountActive,
	)
	return i, err
}

const accountDistributions = `-- name: AccountDistributions :many
SELECT dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active, period_id, period_name, period_start, period_end, period_active, entry_id, entry_year, entry_code, entry_object, entry_amount, account_id, account_abbr, account_name, account_active FROM full_distributions WHERE dist_account = ?
`

func (q *Queries) AccountDistributions(ctx context.Context, distAccount int64) ([]FullDistribution, error) {
	rows, err := q.db.QueryContext(ctx, accountDistributions, distAccount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullDistribution
	for rows.Next() {
		var i FullDistribution
		if err := rows.Scan(
			&i.DistID,
			&i.DistPeriod,
			&i.DistEntryCode,
			&i.DistAccount,
			&i.DistAmount,
			&i.DistActive,
			&i.PeriodID,
			&i.PeriodName,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.PeriodActive,
			&i.EntryID,
			&i.EntryYear,
			&i.EntryCode,
			&i.EntryObject,
			&i.EntryAmount,
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const activeDistributionsByAccountID = `-- name: ActiveDistributionsByAccountID :many
SELECT dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active, period_id, period_name, period_start, period_end, period_active, entry_id, entry_year, entry_code, entry_object, entry_amount, account_id, account_abbr, account_name, account_active FROM full_distributions WHERE dist_account = ? AND dist_active = 1
`

func (q *Queries) ActiveDistributionsByAccountID(ctx context.Context, distAccount int64) ([]FullDistribution, error) {
	rows, err := q.db.QueryContext(ctx, activeDistributionsByAccountID, distAccount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullDistribution
	for rows.Next() {
		var i FullDistribution
		if err := rows.Scan(
			&i.DistID,
			&i.DistPeriod,
			&i.DistEntryCode,
			&i.DistAccount,
			&i.DistAmount,
			&i.DistActive,
			&i.PeriodID,
			&i.PeriodName,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.PeriodActive,
			&i.EntryID,
			&i.EntryYear,
			&i.EntryCode,
			&i.EntryObject,
			&i.EntryAmount,
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const activePermissionByUserIDAndAccountID = `-- name: ActivePermissionByUserIDAndAccountID :one
SELECT a.account_id, a.account_abbr, a.account_name, a.account_active, u.user_id, u.user_email, u.user_name, u.user_active, p.permission_id, p.permission_user, p.permission_account, p.permission_integer, p.permission_active
FROM active_permissions p
JOIN active_users       u ON u.user_id    = p.permission_user
JOIN active_accounts    a ON a.account_id = p.permission_account
WHERE u.user_id = ? AND a.account_id = ?
`

type ActivePermissionByUserIDAndAccountIDParams struct {
	UserID    int64
	AccountID int64
}

type ActivePermissionByUserIDAndAccountIDRow struct {
	AccountID         int64
	AccountAbbr       string
	AccountName       string
	AccountActive     bool
	UserID            int64
	UserEmail         string
	UserName          string
	UserActive        bool
	PermissionID      int64
	PermissionUser    int64
	PermissionAccount int64
	PermissionInteger int64
	PermissionActive  bool
}

func (q *Queries) ActivePermissionByUserIDAndAccountID(ctx context.Context, arg ActivePermissionByUserIDAndAccountIDParams) (ActivePermissionByUserIDAndAccountIDRow, error) {
	row := q.db.QueryRowContext(ctx, activePermissionByUserIDAndAccountID, arg.UserID, arg.AccountID)
	var i ActivePermissionByUserIDAndAccountIDRow
	err := row.Scan(
		&i.AccountID,
		&i.AccountAbbr,
		&i.AccountName,
		&i.AccountActive,
		&i.UserID,
		&i.UserEmail,
		&i.UserName,
		&i.UserActive,
		&i.PermissionID,
		&i.PermissionUser,
		&i.PermissionAccount,
		&i.PermissionInteger,
		&i.PermissionActive,
	)
	return i, err
}

const activePermissionsByUserID = `-- name: ActivePermissionsByUserID :many
SELECT a.account_id, a.account_abbr, a.account_name, a.account_active, u.user_id, u.user_email, u.user_name, u.user_active, p.permission_id, p.permission_user, p.permission_account, p.permission_integer, p.permission_active
FROM active_users       u
JOIN active_permissions p ON u.user_id    = p.permission_user
JOIN active_accounts    a ON a.account_id = p.permission_account
WHERE u.user_id = ?
`

type ActivePermissionsByUserIDRow struct {
	AccountID         int64
	AccountAbbr       string
	AccountName       string
	AccountActive     bool
	UserID            int64
	UserEmail         string
	UserName          string
	UserActive        bool
	PermissionID      int64
	PermissionUser    int64
	PermissionAccount int64
	PermissionInteger int64
	PermissionActive  bool
}

func (q *Queries) ActivePermissionsByUserID(ctx context.Context, userID int64) ([]ActivePermissionsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, activePermissionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivePermissionsByUserIDRow
	for rows.Next() {
		var i ActivePermissionsByUserIDRow
		if err := rows.Scan(
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.UserActive,
			&i.PermissionID,
			&i.PermissionUser,
			&i.PermissionAccount,
			&i.PermissionInteger,
			&i.PermissionActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const activeUserIDByUserEmail = `-- name: ActiveUserIDByUserEmail :one
SELECT user_id FROM active_users
WHERE user_email = ? LIMIT 1
`

func (q *Queries) ActiveUserIDByUserEmail(ctx context.Context, userEmail string) (int64, error) {
	row := q.db.QueryRowContext(ctx, activeUserIDByUserEmail, userEmail)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const addAccount = `-- name: AddAccount :one
INSERT INTO accounts (
    account_abbr,
    account_name,
    account_active
) VALUES (
    ?, ?, ?
)
RETURNING account_id, account_abbr, account_name, account_active
`

type AddAccountParams struct {
	AccountAbbr   string
	AccountName   string
	AccountActive bool
}

func (q *Queries) AddAccount(ctx context.Context, arg AddAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, addAccount, arg.AccountAbbr, arg.AccountName, arg.AccountActive)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.AccountAbbr,
		&i.AccountName,
		&i.AccountActive,
	)
	return i, err
}

const addCatalog = `-- name: AddCatalog :one
INSERT INTO catalogs (
    catalog_supplier,
    catalog_grouping,
    catalog_summary,
    catalog_tags
) VALUES (
    ?, ?, ?, ?
) RETURNING catalog_id, catalog_supplier, catalog_grouping, catalog_summary, catalog_tags
`

type AddCatalogParams struct {
	CatalogSupplier int64
	CatalogGrouping int64
	CatalogSummary  string
	CatalogTags     string
}

func (q *Queries) AddCatalog(ctx context.Context, arg AddCatalogParams) (Catalog, error) {
	row := q.db.QueryRowContext(ctx, addCatalog,
		arg.CatalogSupplier,
		arg.CatalogGrouping,
		arg.CatalogSummary,
		arg.CatalogTags,
	)
	var i Catalog
	err := row.Scan(
		&i.CatalogID,
		&i.CatalogSupplier,
		&i.CatalogGrouping,
		&i.CatalogSummary,
		&i.CatalogTags,
	)
	return i, err
}

const addDistribution = `-- name: AddDistribution :one
INSERT INTO distributions (
    dist_period,
    dist_entry_code,
    dist_account,
    dist_amount,
    dist_active
) VALUES (
    ?, ?, ?, ?, ?
) RETURNING dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active
`

type AddDistributionParams struct {
	DistPeriod    int64
	DistEntryCode int64
	DistAccount   int64
	DistAmount    float64
	DistActive    bool
}

func (q *Queries) AddDistribution(ctx context.Context, arg AddDistributionParams) (Distribution, error) {
	row := q.db.QueryRowContext(ctx, addDistribution,
		arg.DistPeriod,
		arg.DistEntryCode,
		arg.DistAccount,
		arg.DistAmount,
		arg.DistActive,
	)
	var i Distribution
	err := row.Scan(
		&i.DistID,
		&i.DistPeriod,
		&i.DistEntryCode,
		&i.DistAccount,
		&i.DistAmount,
		&i.DistActive,
	)
	return i, err
}

const addItem = `-- name: AddItem :one
INSERT INTO items (
    item_catalog,
    item_number,
    item_summary,
    item_description,
    item_amount
) VALUES (
    ?, ?, ?, ?, ?
) RETURNING item_id, item_catalog, item_number, item_summary, item_description, item_amount
`

type AddItemParams struct {
	ItemCatalog     int64
	ItemNumber      int64
	ItemSummary     string
	ItemDescription string
	ItemAmount      float64
}

func (q *Queries) AddItem(ctx context.Context, arg AddItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, addItem,
		arg.ItemCatalog,
		arg.ItemNumber,
		arg.ItemSummary,
		arg.ItemDescription,
		arg.ItemAmount,
	)
	var i Item
	err := row.Scan(
		&i.ItemID,
		&i.ItemCatalog,
		&i.ItemNumber,
		&i.ItemSummary,
		&i.ItemDescription,
		&i.ItemAmount,
	)
	return i, err
}

const addPeriod = `-- name: AddPeriod :one
INSERT INTO periods (
    period_name,
    period_start,
    period_end,
    period_active
) VALUES (
    ?, ?, ?, ?
) RETURNING period_id, period_name, period_start, period_end, period_active
`

type AddPeriodParams struct {
	PeriodName   string
	PeriodStart  int64
	PeriodEnd    int64
	PeriodActive bool
}

func (q *Queries) AddPeriod(ctx context.Context, arg AddPeriodParams) (Period, error) {
	row := q.db.QueryRowContext(ctx, addPeriod,
		arg.PeriodName,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.PeriodActive,
	)
	var i Period
	err := row.Scan(
		&i.PeriodID,
		&i.PeriodName,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.PeriodActive,
	)
	return i, err
}

const addPermission = `-- name: AddPermission :one
INSERT INTO permissions (
    permission_user,
    permission_account,
    permission_integer,
    permission_active
) VALUES (
    ?, ?, ?, ?
) RETURNING permission_id, permission_user, permission_account, permission_integer, permission_active
`

type AddPermissionParams struct {
	PermissionUser    int64
	PermissionAccount int64
	PermissionInteger int64
	PermissionActive  bool
}

func (q *Queries) AddPermission(ctx context.Context, arg AddPermissionParams) (Permission, error) {
	row := q.db.QueryRowContext(ctx, addPermission,
		arg.PermissionUser,
		arg.PermissionAccount,
		arg.PermissionInteger,
		arg.PermissionActive,
	)
	var i Permission
	err := row.Scan(
		&i.PermissionID,
		&i.PermissionUser,
		&i.PermissionAccount,
		&i.PermissionInteger,
		&i.PermissionActive,
	)
	return i, err
}

const addPurchase = `-- name: AddPurchase :one
INSERT INTO purchases (
    purchase_request,
    purchase_required,
    purchase_supplier,
    purchase_currency,
    purchase_ex_rate_colones,
    purchase_gross_amount,
    purchase_discount,
    purchase_tax_rate,
    purchase_geco_sol,
    purchase_geco_ord,
    purchase_bill,
    purchase_transfer,
    purchase_status
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING purchase_id, purchase_request, purchase_required, purchase_supplier, purchase_currency, purchase_ex_rate_colones, purchase_gross_amount, purchase_discount, purchase_tax_rate, purchase_geco_sol, purchase_geco_ord, purchase_bill, purchase_transfer, purchase_status
`

type AddPurchaseParams struct {
	PurchaseRequest       int64
	PurchaseRequired      int64
	PurchaseSupplier      int64
	PurchaseCurrency      string
	PurchaseExRateColones float64
	PurchaseGrossAmount   float64
	PurchaseDiscount      float64
	PurchaseTaxRate       float64
	PurchaseGecoSol       string
	PurchaseGecoOrd       string
	PurchaseBill          string
	PurchaseTransfer      string
	PurchaseStatus        string
}

func (q *Queries) AddPurchase(ctx context.Context, arg AddPurchaseParams) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, addPurchase,
		arg.PurchaseRequest,
		arg.PurchaseRequired,
		arg.PurchaseSupplier,
		arg.PurchaseCurrency,
		arg.PurchaseExRateColones,
		arg.PurchaseGrossAmount,
		arg.PurchaseDiscount,
		arg.PurchaseTaxRate,
		arg.PurchaseGecoSol,
		arg.PurchaseGecoOrd,
		arg.PurchaseBill,
		arg.PurchaseTransfer,
		arg.PurchaseStatus,
	)
	var i Purchase
	err := row.Scan(
		&i.PurchaseID,
		&i.PurchaseRequest,
		&i.PurchaseRequired,
		&i.PurchaseSupplier,
		&i.PurchaseCurrency,
		&i.PurchaseExRateColones,
		&i.PurchaseGrossAmount,
		&i.PurchaseDiscount,
		&i.PurchaseTaxRate,
		&i.PurchaseGecoSol,
		&i.PurchaseGecoOrd,
		&i.PurchaseBill,
		&i.PurchaseTransfer,
		&i.PurchaseStatus,
	)
	return i, err
}

const addPurchaseBreakdown = `-- name: AddPurchaseBreakdown :one
INSERT INTO purchase_breakdowns (
    "breakdown_purchase",
    "breakdown_item",
    "breakdown_quantity"
) VALUES (
    ?, ?, ?
) RETURNING breakdown_id, breakdown_purchase, breakdown_item, breakdown_quantity
`

type AddPurchaseBreakdownParams struct {
	BreakdownPurchase int64
	BreakdownItem     int64
	BreakdownQuantity float64
}

func (q *Queries) AddPurchaseBreakdown(ctx context.Context, arg AddPurchaseBreakdownParams) (PurchaseBreakdown, error) {
	row := q.db.QueryRowContext(ctx, addPurchaseBreakdown, arg.BreakdownPurchase, arg.BreakdownItem, arg.BreakdownQuantity)
	var i PurchaseBreakdown
	err := row.Scan(
		&i.BreakdownID,
		&i.BreakdownPurchase,
		&i.BreakdownItem,
		&i.BreakdownQuantity,
	)
	return i, err
}

const addPurchaseSub = `-- name: AddPurchaseSub :one
INSERT INTO purchase_subscriptions (
    subscription_gross_amount,
    subscription_signature,
    subscription_signed,
    subscription_active
) VALUES (
    ?, ?, ?, ?
) RETURNING subscription_id, subscription_purchase, subscription_user, subscription_dist, subscription_issued, subscription_gross_amount, subscription_signature, subscription_signed, subscription_active
`

type AddPurchaseSubParams struct {
	SubscriptionGrossAmount float64
	SubscriptionSignature   string
	SubscriptionSigned      bool
	SubscriptionActive      bool
}

func (q *Queries) AddPurchaseSub(ctx context.Context, arg AddPurchaseSubParams) (PurchaseSubscription, error) {
	row := q.db.QueryRowContext(ctx, addPurchaseSub,
		arg.SubscriptionGrossAmount,
		arg.SubscriptionSignature,
		arg.SubscriptionSigned,
		arg.SubscriptionActive,
	)
	var i PurchaseSubscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.SubscriptionPurchase,
		&i.SubscriptionUser,
		&i.SubscriptionDist,
		&i.SubscriptionIssued,
		&i.SubscriptionGrossAmount,
		&i.SubscriptionSignature,
		&i.SubscriptionSigned,
		&i.SubscriptionActive,
	)
	return i, err
}

const addPurchaseSubscription = `-- name: AddPurchaseSubscription :one
INSERT INTO purchase_subscriptions (
    "subscription_purchase",
    "subscription_user",
    "subscription_dist",
    "subscription_issued",
    "subscription_gross_amount",
    "subscription_signature",
    "subscription_signed",
    "subscription_active"
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING subscription_id, subscription_purchase, subscription_user, subscription_dist, subscription_issued, subscription_gross_amount, subscription_signature, subscription_signed, subscription_active
`

type AddPurchaseSubscriptionParams struct {
	SubscriptionPurchase    int64
	SubscriptionUser        int64
	SubscriptionDist        int64
	SubscriptionIssued      int64
	SubscriptionGrossAmount float64
	SubscriptionSignature   string
	SubscriptionSigned      bool
	SubscriptionActive      bool
}

func (q *Queries) AddPurchaseSubscription(ctx context.Context, arg AddPurchaseSubscriptionParams) (PurchaseSubscription, error) {
	row := q.db.QueryRowContext(ctx, addPurchaseSubscription,
		arg.SubscriptionPurchase,
		arg.SubscriptionUser,
		arg.SubscriptionDist,
		arg.SubscriptionIssued,
		arg.SubscriptionGrossAmount,
		arg.SubscriptionSignature,
		arg.SubscriptionSigned,
		arg.SubscriptionActive,
	)
	var i PurchaseSubscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.SubscriptionPurchase,
		&i.SubscriptionUser,
		&i.SubscriptionDist,
		&i.SubscriptionIssued,
		&i.SubscriptionGrossAmount,
		&i.SubscriptionSignature,
		&i.SubscriptionSigned,
		&i.SubscriptionActive,
	)
	return i, err
}

const addRequest = `-- name: AddRequest :one
INSERT INTO requests (
    req_user,
    req_account,
    req_issued,
    req_descr,
    req_justif
) VALUES (
    ?, ?, ?, ?, ?
) RETURNING req_id, req_user, req_account, req_issued, req_descr, req_justif
`

type AddRequestParams struct {
	ReqUser    int64
	ReqAccount int64
	ReqIssued  int64
	ReqDescr   string
	ReqJustif  string
}

func (q *Queries) AddRequest(ctx context.Context, arg AddRequestParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, addRequest,
		arg.ReqUser,
		arg.ReqAccount,
		arg.ReqIssued,
		arg.ReqDescr,
		arg.ReqJustif,
	)
	var i Request
	err := row.Scan(
		&i.ReqID,
		&i.ReqUser,
		&i.ReqAccount,
		&i.ReqIssued,
		&i.ReqDescr,
		&i.ReqJustif,
	)
	return i, err
}

const addSupplier = `-- name: AddSupplier :one
INSERT INTO suppliers (
    supplier_id,
    supplier_name,
    supplier_email,
    supplier_phone_country_code,
    supplier_phone,
    supplier_location
) VALUES (
    ?, ?, ?, ?, ?, ?
) RETURNING supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location
`

type AddSupplierParams struct {
	SupplierID               int64
	SupplierName             string
	SupplierEmail            string
	SupplierPhoneCountryCode int64
	SupplierPhone            int64
	SupplierLocation         string
}

func (q *Queries) AddSupplier(ctx context.Context, arg AddSupplierParams) (Supplier, error) {
	row := q.db.QueryRowContext(ctx, addSupplier,
		arg.SupplierID,
		arg.SupplierName,
		arg.SupplierEmail,
		arg.SupplierPhoneCountryCode,
		arg.SupplierPhone,
		arg.SupplierLocation,
	)
	var i Supplier
	err := row.Scan(
		&i.SupplierID,
		&i.SupplierName,
		&i.SupplierEmail,
		&i.SupplierPhoneCountryCode,
		&i.SupplierPhone,
		&i.SupplierLocation,
	)
	return i, err
}

const allAccounts = `-- name: AllAccounts :many
SELECT account_id, account_abbr, account_name, account_active FROM accounts
`

func (q *Queries) AllAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, allAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allActiveDistributions = `-- name: AllActiveDistributions :many
SELECT dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active, period_id, period_name, period_start, period_end, period_active, entry_id, entry_year, entry_code, entry_object, entry_amount, account_id, account_abbr, account_name, account_active FROM full_distributions WHERE dist_active = 1
`

func (q *Queries) AllActiveDistributions(ctx context.Context) ([]FullDistribution, error) {
	rows, err := q.db.QueryContext(ctx, allActiveDistributions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullDistribution
	for rows.Next() {
		var i FullDistribution
		if err := rows.Scan(
			&i.DistID,
			&i.DistPeriod,
			&i.DistEntryCode,
			&i.DistAccount,
			&i.DistAmount,
			&i.DistActive,
			&i.PeriodID,
			&i.PeriodName,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.PeriodActive,
			&i.EntryID,
			&i.EntryYear,
			&i.EntryCode,
			&i.EntryObject,
			&i.EntryAmount,
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allCatalogItems = `-- name: AllCatalogItems :many
SELECT item_id, item_catalog, item_number, item_summary, item_description, item_amount, catalog_id, catalog_supplier, catalog_grouping, catalog_summary, catalog_tags, supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location FROM full_catalog_items
`

func (q *Queries) AllCatalogItems(ctx context.Context) ([]FullCatalogItem, error) {
	rows, err := q.db.QueryContext(ctx, allCatalogItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullCatalogItem
	for rows.Next() {
		var i FullCatalogItem
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemCatalog,
			&i.ItemNumber,
			&i.ItemSummary,
			&i.ItemDescription,
			&i.ItemAmount,
			&i.CatalogID,
			&i.CatalogSupplier,
			&i.CatalogGrouping,
			&i.CatalogSummary,
			&i.CatalogTags,
			&i.SupplierID,
			&i.SupplierName,
			&i.SupplierEmail,
			&i.SupplierPhoneCountryCode,
			&i.SupplierPhone,
			&i.SupplierLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allCatalogs = `-- name: AllCatalogs :many
SELECT catalog_id, catalog_supplier, catalog_grouping, catalog_summary, catalog_tags, supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location FROM full_catalogs
`

func (q *Queries) AllCatalogs(ctx context.Context) ([]FullCatalog, error) {
	rows, err := q.db.QueryContext(ctx, allCatalogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullCatalog
	for rows.Next() {
		var i FullCatalog
		if err := rows.Scan(
			&i.CatalogID,
			&i.CatalogSupplier,
			&i.CatalogGrouping,
			&i.CatalogSummary,
			&i.CatalogTags,
			&i.SupplierID,
			&i.SupplierName,
			&i.SupplierEmail,
			&i.SupplierPhoneCountryCode,
			&i.SupplierPhone,
			&i.SupplierLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allDistributions = `-- name: AllDistributions :many
SELECT dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active, period_id, period_name, period_start, period_end, period_active, entry_id, entry_year, entry_code, entry_object, entry_amount, account_id, account_abbr, account_name, account_active FROM full_distributions
`

func (q *Queries) AllDistributions(ctx context.Context) ([]FullDistribution, error) {
	rows, err := q.db.QueryContext(ctx, allDistributions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullDistribution
	for rows.Next() {
		var i FullDistribution
		if err := rows.Scan(
			&i.DistID,
			&i.DistPeriod,
			&i.DistEntryCode,
			&i.DistAccount,
			&i.DistAmount,
			&i.DistActive,
			&i.PeriodID,
			&i.PeriodName,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.PeriodActive,
			&i.EntryID,
			&i.EntryYear,
			&i.EntryCode,
			&i.EntryObject,
			&i.EntryAmount,
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allPeriods = `-- name: AllPeriods :many
SELECT period_id, period_name, period_start, period_end, period_active FROM periods
`

func (q *Queries) AllPeriods(ctx context.Context) ([]Period, error) {
	rows, err := q.db.QueryContext(ctx, allPeriods)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Period
	for rows.Next() {
		var i Period
		if err := rows.Scan(
			&i.PeriodID,
			&i.PeriodName,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.PeriodActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allPermissions = `-- name: AllPermissions :many
SELECT a.account_id, a.account_abbr, a.account_name, a.account_active, u.user_id, u.user_email, u.user_name, u.user_active, p.permission_id, p.permission_user, p.permission_account, p.permission_integer, p.permission_active
FROM users       u
JOIN permissions p ON u.user_id    = p.permission_user
JOIN accounts    a ON a.account_id = p.permission_account
`

type AllPermissionsRow struct {
	AccountID         int64
	AccountAbbr       string
	AccountName       string
	AccountActive     bool
	UserID            int64
	UserEmail         string
	UserName          string
	UserActive        bool
	PermissionID      int64
	PermissionUser    int64
	PermissionAccount int64
	PermissionInteger int64
	PermissionActive  bool
}

func (q *Queries) AllPermissions(ctx context.Context) ([]AllPermissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, allPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllPermissionsRow
	for rows.Next() {
		var i AllPermissionsRow
		if err := rows.Scan(
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.UserActive,
			&i.PermissionID,
			&i.PermissionUser,
			&i.PermissionAccount,
			&i.PermissionInteger,
			&i.PermissionActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allPurchaseSubscriptions = `-- name: AllPurchaseSubscriptions :many
SELECT subscription_id, subscription_purchase, subscription_user, subscription_dist, subscription_issued, subscription_gross_amount, subscription_signature, subscription_signed, subscription_active, purchase_id, purchase_request, purchase_required, purchase_supplier, purchase_currency, purchase_ex_rate_colones, purchase_gross_amount, purchase_discount, purchase_tax_rate, purchase_geco_sol, purchase_geco_ord, purchase_bill, purchase_transfer, purchase_status, user_id, user_email, user_name, user_active, dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active, req_id, req_user, req_account, req_issued, req_descr, req_justif, entry_id, entry_year, entry_code, entry_object, entry_amount, account_id, account_abbr, account_name, account_active, period_id, period_name, period_start, period_end, period_active, supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location FROM full_purchase_subscriptions
`

func (q *Queries) AllPurchaseSubscriptions(ctx context.Context) ([]FullPurchaseSubscription, error) {
	rows, err := q.db.QueryContext(ctx, allPurchaseSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullPurchaseSubscription
	for rows.Next() {
		var i FullPurchaseSubscription
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.SubscriptionPurchase,
			&i.SubscriptionUser,
			&i.SubscriptionDist,
			&i.SubscriptionIssued,
			&i.SubscriptionGrossAmount,
			&i.SubscriptionSignature,
			&i.SubscriptionSigned,
			&i.SubscriptionActive,
			&i.PurchaseID,
			&i.PurchaseRequest,
			&i.PurchaseRequired,
			&i.PurchaseSupplier,
			&i.PurchaseCurrency,
			&i.PurchaseExRateColones,
			&i.PurchaseGrossAmount,
			&i.PurchaseDiscount,
			&i.PurchaseTaxRate,
			&i.PurchaseGecoSol,
			&i.PurchaseGecoOrd,
			&i.PurchaseBill,
			&i.PurchaseTransfer,
			&i.PurchaseStatus,
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.UserActive,
			&i.DistID,
			&i.DistPeriod,
			&i.DistEntryCode,
			&i.DistAccount,
			&i.DistAmount,
			&i.DistActive,
			&i.ReqID,
			&i.ReqUser,
			&i.ReqAccount,
			&i.ReqIssued,
			&i.ReqDescr,
			&i.ReqJustif,
			&i.EntryID,
			&i.EntryYear,
			&i.EntryCode,
			&i.EntryObject,
			&i.EntryAmount,
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
			&i.PeriodID,
			&i.PeriodName,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.PeriodActive,
			&i.SupplierID,
			&i.SupplierName,
			&i.SupplierEmail,
			&i.SupplierPhoneCountryCode,
			&i.SupplierPhone,
			&i.SupplierLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allPurchases = `-- name: AllPurchases :many
SELECT purchase_id, purchase_request, purchase_required, purchase_supplier, purchase_currency, purchase_ex_rate_colones, purchase_gross_amount, purchase_discount, purchase_tax_rate, purchase_geco_sol, purchase_geco_ord, purchase_bill, purchase_transfer, purchase_status, req_id, req_user, req_account, req_issued, req_descr, req_justif, user_id, user_email, user_name, user_active, supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location FROM full_purchases
`

func (q *Queries) AllPurchases(ctx context.Context) ([]FullPurchase, error) {
	rows, err := q.db.QueryContext(ctx, allPurchases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullPurchase
	for rows.Next() {
		var i FullPurchase
		if err := rows.Scan(
			&i.PurchaseID,
			&i.PurchaseRequest,
			&i.PurchaseRequired,
			&i.PurchaseSupplier,
			&i.PurchaseCurrency,
			&i.PurchaseExRateColones,
			&i.PurchaseGrossAmount,
			&i.PurchaseDiscount,
			&i.PurchaseTaxRate,
			&i.PurchaseGecoSol,
			&i.PurchaseGecoOrd,
			&i.PurchaseBill,
			&i.PurchaseTransfer,
			&i.PurchaseStatus,
			&i.ReqID,
			&i.ReqUser,
			&i.ReqAccount,
			&i.ReqIssued,
			&i.ReqDescr,
			&i.ReqJustif,
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.UserActive,
			&i.SupplierID,
			&i.SupplierName,
			&i.SupplierEmail,
			&i.SupplierPhoneCountryCode,
			&i.SupplierPhone,
			&i.SupplierLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allSuppliers = `-- name: AllSuppliers :many
SELECT supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location FROM suppliers
`

func (q *Queries) AllSuppliers(ctx context.Context) ([]Supplier, error) {
	rows, err := q.db.QueryContext(ctx, allSuppliers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supplier
	for rows.Next() {
		var i Supplier
		if err := rows.Scan(
			&i.SupplierID,
			&i.SupplierName,
			&i.SupplierEmail,
			&i.SupplierPhoneCountryCode,
			&i.SupplierPhone,
			&i.SupplierLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allUsers = `-- name: AllUsers :many
SELECT user_id, user_email, user_name, user_active FROM users
`

func (q *Queries) AllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, allUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.UserActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const breakdownsByPurchaseID = `-- name: BreakdownsByPurchaseID :many
SELECT breakdown_id, breakdown_purchase, breakdown_item, breakdown_quantity, purchase_id, purchase_request, purchase_required, purchase_supplier, purchase_currency, purchase_ex_rate_colones, purchase_gross_amount, purchase_discount, purchase_tax_rate, purchase_geco_sol, purchase_geco_ord, purchase_bill, purchase_transfer, purchase_status, item_id, item_catalog, item_number, item_summary, item_description, item_amount, catalog_id, catalog_supplier, catalog_grouping, catalog_summary, catalog_tags FROM full_purchase_breakdowns
WHERE breakdown_purchase = ?
`

func (q *Queries) BreakdownsByPurchaseID(ctx context.Context, breakdownPurchase int64) ([]FullPurchaseBreakdown, error) {
	rows, err := q.db.QueryContext(ctx, breakdownsByPurchaseID, breakdownPurchase)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullPurchaseBreakdown
	for rows.Next() {
		var i FullPurchaseBreakdown
		if err := rows.Scan(
			&i.BreakdownID,
			&i.BreakdownPurchase,
			&i.BreakdownItem,
			&i.BreakdownQuantity,
			&i.PurchaseID,
			&i.PurchaseRequest,
			&i.PurchaseRequired,
			&i.PurchaseSupplier,
			&i.PurchaseCurrency,
			&i.PurchaseExRateColones,
			&i.PurchaseGrossAmount,
			&i.PurchaseDiscount,
			&i.PurchaseTaxRate,
			&i.PurchaseGecoSol,
			&i.PurchaseGecoOrd,
			&i.PurchaseBill,
			&i.PurchaseTransfer,
			&i.PurchaseStatus,
			&i.ItemID,
			&i.ItemCatalog,
			&i.ItemNumber,
			&i.ItemSummary,
			&i.ItemDescription,
			&i.ItemAmount,
			&i.CatalogID,
			&i.CatalogSupplier,
			&i.CatalogGrouping,
			&i.CatalogSummary,
			&i.CatalogTags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const catalogByID = `-- name: CatalogByID :one
SELECT catalog_id, catalog_supplier, catalog_grouping, catalog_summary, catalog_tags, supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location FROM full_catalogs
WHERE catalog_id = ?
`

func (q *Queries) CatalogByID(ctx context.Context, catalogID int64) (FullCatalog, error) {
	row := q.db.QueryRowContext(ctx, catalogByID, catalogID)
	var i FullCatalog
	err := row.Scan(
		&i.CatalogID,
		&i.CatalogSupplier,
		&i.CatalogGrouping,
		&i.CatalogSummary,
		&i.CatalogTags,
		&i.SupplierID,
		&i.SupplierName,
		&i.SupplierEmail,
		&i.SupplierPhoneCountryCode,
		&i.SupplierPhone,
		&i.SupplierLocation,
	)
	return i, err
}

const catalogItemByID = `-- name: CatalogItemByID :one
SELECT item_id, item_catalog, item_number, item_summary, item_description, item_amount, catalog_id, catalog_supplier, catalog_grouping, catalog_summary, catalog_tags, supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location FROM full_catalog_items
WHERE item_id = ?
`

func (q *Queries) CatalogItemByID(ctx context.Context, itemID int64) (FullCatalogItem, error) {
	row := q.db.QueryRowContext(ctx, catalogItemByID, itemID)
	var i FullCatalogItem
	err := row.Scan(
		&i.ItemID,
		&i.ItemCatalog,
		&i.ItemNumber,
		&i.ItemSummary,
		&i.ItemDescription,
		&i.ItemAmount,
		&i.CatalogID,
		&i.CatalogSupplier,
		&i.CatalogGrouping,
		&i.CatalogSummary,
		&i.CatalogTags,
		&i.SupplierID,
		&i.SupplierName,
		&i.SupplierEmail,
		&i.SupplierPhoneCountryCode,
		&i.SupplierPhone,
		&i.SupplierLocation,
	)
	return i, err
}

const distributionByID = `-- name: DistributionByID :one
SELECT dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active, period_id, period_name, period_start, period_end, period_active, entry_id, entry_year, entry_code, entry_object, entry_amount, account_id, account_abbr, account_name, account_active FROM full_distributions
WHERE dist_id = ?
`

func (q *Queries) DistributionByID(ctx context.Context, distID int64) (FullDistribution, error) {
	row := q.db.QueryRowContext(ctx, distributionByID, distID)
	var i FullDistribution
	err := row.Scan(
		&i.DistID,
		&i.DistPeriod,
		&i.DistEntryCode,
		&i.DistAccount,
		&i.DistAmount,
		&i.DistActive,
		&i.PeriodID,
		&i.PeriodName,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.PeriodActive,
		&i.EntryID,
		&i.EntryYear,
		&i.EntryCode,
		&i.EntryObject,
		&i.EntryAmount,
		&i.AccountID,
		&i.AccountAbbr,
		&i.AccountName,
		&i.AccountActive,
	)
	return i, err
}

const fullPurchaseByReqID = `-- name: FullPurchaseByReqID :one
SELECT purchase_id, purchase_request, purchase_required, purchase_supplier, purchase_currency, purchase_ex_rate_colones, purchase_gross_amount, purchase_discount, purchase_tax_rate, purchase_geco_sol, purchase_geco_ord, purchase_bill, purchase_transfer, purchase_status, req_id, req_user, req_account, req_issued, req_descr, req_justif, user_id, user_email, user_name, user_active, supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location FROM full_purchases
WHERE req_id = ?
`

func (q *Queries) FullPurchaseByReqID(ctx context.Context, reqID int64) (FullPurchase, error) {
	row := q.db.QueryRowContext(ctx, fullPurchaseByReqID, reqID)
	var i FullPurchase
	err := row.Scan(
		&i.PurchaseID,
		&i.PurchaseRequest,
		&i.PurchaseRequired,
		&i.PurchaseSupplier,
		&i.PurchaseCurrency,
		&i.PurchaseExRateColones,
		&i.PurchaseGrossAmount,
		&i.PurchaseDiscount,
		&i.PurchaseTaxRate,
		&i.PurchaseGecoSol,
		&i.PurchaseGecoOrd,
		&i.PurchaseBill,
		&i.PurchaseTransfer,
		&i.PurchaseStatus,
		&i.ReqID,
		&i.ReqUser,
		&i.ReqAccount,
		&i.ReqIssued,
		&i.ReqDescr,
		&i.ReqJustif,
		&i.UserID,
		&i.UserEmail,
		&i.UserName,
		&i.UserActive,
		&i.SupplierID,
		&i.SupplierName,
		&i.SupplierEmail,
		&i.SupplierPhoneCountryCode,
		&i.SupplierPhone,
		&i.SupplierLocation,
	)
	return i, err
}

const fullPurchaseSubscriptionsByDistID = `-- name: FullPurchaseSubscriptionsByDistID :many
SELECT subscription_id, subscription_purchase, subscription_user, subscription_dist, subscription_issued, subscription_gross_amount, subscription_signature, subscription_signed, subscription_active, purchase_id, purchase_request, purchase_required, purchase_supplier, purchase_currency, purchase_ex_rate_colones, purchase_gross_amount, purchase_discount, purchase_tax_rate, purchase_geco_sol, purchase_geco_ord, purchase_bill, purchase_transfer, purchase_status, user_id, user_email, user_name, user_active, dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active, req_id, req_user, req_account, req_issued, req_descr, req_justif, entry_id, entry_year, entry_code, entry_object, entry_amount, account_id, account_abbr, account_name, account_active, period_id, period_name, period_start, period_end, period_active, supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location FROM full_purchase_subscriptions
WHERE subscription_dist = ?
`

func (q *Queries) FullPurchaseSubscriptionsByDistID(ctx context.Context, subscriptionDist int64) ([]FullPurchaseSubscription, error) {
	rows, err := q.db.QueryContext(ctx, fullPurchaseSubscriptionsByDistID, subscriptionDist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullPurchaseSubscription
	for rows.Next() {
		var i FullPurchaseSubscription
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.SubscriptionPurchase,
			&i.SubscriptionUser,
			&i.SubscriptionDist,
			&i.SubscriptionIssued,
			&i.SubscriptionGrossAmount,
			&i.SubscriptionSignature,
			&i.SubscriptionSigned,
			&i.SubscriptionActive,
			&i.PurchaseID,
			&i.PurchaseRequest,
			&i.PurchaseRequired,
			&i.PurchaseSupplier,
			&i.PurchaseCurrency,
			&i.PurchaseExRateColones,
			&i.PurchaseGrossAmount,
			&i.PurchaseDiscount,
			&i.PurchaseTaxRate,
			&i.PurchaseGecoSol,
			&i.PurchaseGecoOrd,
			&i.PurchaseBill,
			&i.PurchaseTransfer,
			&i.PurchaseStatus,
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.UserActive,
			&i.DistID,
			&i.DistPeriod,
			&i.DistEntryCode,
			&i.DistAccount,
			&i.DistAmount,
			&i.DistActive,
			&i.ReqID,
			&i.ReqUser,
			&i.ReqAccount,
			&i.ReqIssued,
			&i.ReqDescr,
			&i.ReqJustif,
			&i.EntryID,
			&i.EntryYear,
			&i.EntryCode,
			&i.EntryObject,
			&i.EntryAmount,
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
			&i.PeriodID,
			&i.PeriodName,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.PeriodActive,
			&i.SupplierID,
			&i.SupplierName,
			&i.SupplierEmail,
			&i.SupplierPhoneCountryCode,
			&i.SupplierPhone,
			&i.SupplierLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBudgetEntries = `-- name: GetAllBudgetEntries :many
SELECT entry_id, entry_year, entry_code, entry_object, entry_amount FROM budget_entries
`

func (q *Queries) GetAllBudgetEntries(ctx context.Context) ([]BudgetEntry, error) {
	rows, err := q.db.QueryContext(ctx, getAllBudgetEntries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BudgetEntry
	for rows.Next() {
		var i BudgetEntry
		if err := rows.Scan(
			&i.EntryID,
			&i.EntryYear,
			&i.EntryCode,
			&i.EntryObject,
			&i.EntryAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const itemAmountByID = `-- name: ItemAmountByID :one
SELECT item_amount FROM items
WHERE item_id = ?
`

func (q *Queries) ItemAmountByID(ctx context.Context, itemID int64) (float64, error) {
	row := q.db.QueryRowContext(ctx, itemAmountByID, itemID)
	var item_amount float64
	err := row.Scan(&item_amount)
	return item_amount, err
}

const newBudgetEntry = `-- name: NewBudgetEntry :one
INSERT INTO budget_entries (
    entry_year,
    entry_code,
    entry_object,
    entry_amount
) VALUES (
    ?, ?, ?, ?
) RETURNING entry_id, entry_year, entry_code, entry_object, entry_amount
`

type NewBudgetEntryParams struct {
	EntryYear   int64
	EntryCode   int64
	EntryObject string
	EntryAmount float64
}

func (q *Queries) NewBudgetEntry(ctx context.Context, arg NewBudgetEntryParams) (BudgetEntry, error) {
	row := q.db.QueryRowContext(ctx, newBudgetEntry,
		arg.EntryYear,
		arg.EntryCode,
		arg.EntryObject,
		arg.EntryAmount,
	)
	var i BudgetEntry
	err := row.Scan(
		&i.EntryID,
		&i.EntryYear,
		&i.EntryCode,
		&i.EntryObject,
		&i.EntryAmount,
	)
	return i, err
}

const newUser = `-- name: NewUser :one
INSERT INTO users (
    user_email,
    user_name,
    user_active
) VALUES (
    ?, ?, ?
)
RETURNING user_id, user_email, user_name, user_active
`

type NewUserParams struct {
	UserEmail  string
	UserName   string
	UserActive bool
}

func (q *Queries) NewUser(ctx context.Context, arg NewUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, newUser, arg.UserEmail, arg.UserName, arg.UserActive)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserName,
		&i.UserActive,
	)
	return i, err
}

const patchPurchaseCommon = `-- name: PatchPurchaseCommon :one
UPDATE purchases SET
    purchase_required = ?,
    purchase_supplier = ?,
    purchase_gross_amount = ?
WHERE purchase_id = ?
RETURNING purchase_id, purchase_request, purchase_required, purchase_supplier, purchase_currency, purchase_ex_rate_colones, purchase_gross_amount, purchase_discount, purchase_tax_rate, purchase_geco_sol, purchase_geco_ord, purchase_bill, purchase_transfer, purchase_status
`

type PatchPurchaseCommonParams struct {
	PurchaseRequired    int64
	PurchaseSupplier    int64
	PurchaseGrossAmount float64
	PurchaseID          int64
}

func (q *Queries) PatchPurchaseCommon(ctx context.Context, arg PatchPurchaseCommonParams) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, patchPurchaseCommon,
		arg.PurchaseRequired,
		arg.PurchaseSupplier,
		arg.PurchaseGrossAmount,
		arg.PurchaseID,
	)
	var i Purchase
	err := row.Scan(
		&i.PurchaseID,
		&i.PurchaseRequest,
		&i.PurchaseRequired,
		&i.PurchaseSupplier,
		&i.PurchaseCurrency,
		&i.PurchaseExRateColones,
		&i.PurchaseGrossAmount,
		&i.PurchaseDiscount,
		&i.PurchaseTaxRate,
		&i.PurchaseGecoSol,
		&i.PurchaseGecoOrd,
		&i.PurchaseBill,
		&i.PurchaseTransfer,
		&i.PurchaseStatus,
	)
	return i, err
}

const patchPurchaseMeta = `-- name: PatchPurchaseMeta :one
UPDATE purchases SET
    purchase_geco_sol = ?,
    purchase_geco_ord = ?,
    purchase_bill = ?,
    purchase_transfer = ?,
    purchase_status = ?
WHERE purchase_id = ?
RETURNING purchase_id, purchase_request, purchase_required, purchase_supplier, purchase_currency, purchase_ex_rate_colones, purchase_gross_amount, purchase_discount, purchase_tax_rate, purchase_geco_sol, purchase_geco_ord, purchase_bill, purchase_transfer, purchase_status
`

type PatchPurchaseMetaParams struct {
	PurchaseGecoSol  string
	PurchaseGecoOrd  string
	PurchaseBill     string
	PurchaseTransfer string
	PurchaseStatus   string
	PurchaseID       int64
}

func (q *Queries) PatchPurchaseMeta(ctx context.Context, arg PatchPurchaseMetaParams) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, patchPurchaseMeta,
		arg.PurchaseGecoSol,
		arg.PurchaseGecoOrd,
		arg.PurchaseBill,
		arg.PurchaseTransfer,
		arg.PurchaseStatus,
		arg.PurchaseID,
	)
	var i Purchase
	err := row.Scan(
		&i.PurchaseID,
		&i.PurchaseRequest,
		&i.PurchaseRequired,
		&i.PurchaseSupplier,
		&i.PurchaseCurrency,
		&i.PurchaseExRateColones,
		&i.PurchaseGrossAmount,
		&i.PurchaseDiscount,
		&i.PurchaseTaxRate,
		&i.PurchaseGecoSol,
		&i.PurchaseGecoOrd,
		&i.PurchaseBill,
		&i.PurchaseTransfer,
		&i.PurchaseStatus,
	)
	return i, err
}

const patchPurchaseSub = `-- name: PatchPurchaseSub :one
UPDATE purchase_subscriptions SET
    subscription_purchase     = ?,
    subscription_user         = ?,
    subscription_dist         = ?,
    subscription_issued       = ?,
    subscription_gross_amount = ?,
    subscription_signature    = ?,
    subscription_signed       = ?,
    subscription_active       = ?
WHERE subscription_id = ?
RETURNING subscription_id, subscription_purchase, subscription_user, subscription_dist, subscription_issued, subscription_gross_amount, subscription_signature, subscription_signed, subscription_active
`

type PatchPurchaseSubParams struct {
	SubscriptionPurchase    int64
	SubscriptionUser        int64
	SubscriptionDist        int64
	SubscriptionIssued      int64
	SubscriptionGrossAmount float64
	SubscriptionSignature   string
	SubscriptionSigned      bool
	SubscriptionActive      bool
	SubscriptionID          int64
}

func (q *Queries) PatchPurchaseSub(ctx context.Context, arg PatchPurchaseSubParams) (PurchaseSubscription, error) {
	row := q.db.QueryRowContext(ctx, patchPurchaseSub,
		arg.SubscriptionPurchase,
		arg.SubscriptionUser,
		arg.SubscriptionDist,
		arg.SubscriptionIssued,
		arg.SubscriptionGrossAmount,
		arg.SubscriptionSignature,
		arg.SubscriptionSigned,
		arg.SubscriptionActive,
		arg.SubscriptionID,
	)
	var i PurchaseSubscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.SubscriptionPurchase,
		&i.SubscriptionUser,
		&i.SubscriptionDist,
		&i.SubscriptionIssued,
		&i.SubscriptionGrossAmount,
		&i.SubscriptionSignature,
		&i.SubscriptionSigned,
		&i.SubscriptionActive,
	)
	return i, err
}

const patchRequestCommon = `-- name: PatchRequestCommon :one
UPDATE requests SET
    req_descr = ?,
    req_justif = ?
WHERE req_id = ?
RETURNING req_id, req_user, req_account, req_issued, req_descr, req_justif
`

type PatchRequestCommonParams struct {
	ReqDescr  string
	ReqJustif string
	ReqID     int64
}

func (q *Queries) PatchRequestCommon(ctx context.Context, arg PatchRequestCommonParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, patchRequestCommon, arg.ReqDescr, arg.ReqJustif, arg.ReqID)
	var i Request
	err := row.Scan(
		&i.ReqID,
		&i.ReqUser,
		&i.ReqAccount,
		&i.ReqIssued,
		&i.ReqDescr,
		&i.ReqJustif,
	)
	return i, err
}

const permissionByID = `-- name: PermissionByID :one
SELECT permission_id, permission_user, permission_account, permission_integer, permission_active FROM permissions
WHERE permission_id = ?
`

func (q *Queries) PermissionByID(ctx context.Context, permissionID int64) (Permission, error) {
	row := q.db.QueryRowContext(ctx, permissionByID, permissionID)
	var i Permission
	err := row.Scan(
		&i.PermissionID,
		&i.PermissionUser,
		&i.PermissionAccount,
		&i.PermissionInteger,
		&i.PermissionActive,
	)
	return i, err
}

const permissionByUserIDAndAccountID = `-- name: PermissionByUserIDAndAccountID :one
SELECT a.account_id, a.account_abbr, a.account_name, a.account_active, u.user_id, u.user_email, u.user_name, u.user_active, p.permission_id, p.permission_user, p.permission_account, p.permission_integer, p.permission_active
FROM permissions p
JOIN users       u ON u.user_id    = p.permission_user
JOIN accounts    a ON a.account_id = p.permission_account
WHERE u.user_id = ? AND a.account_id = ?
`

type PermissionByUserIDAndAccountIDParams struct {
	UserID    int64
	AccountID int64
}

type PermissionByUserIDAndAccountIDRow struct {
	AccountID         int64
	AccountAbbr       string
	AccountName       string
	AccountActive     bool
	UserID            int64
	UserEmail         string
	UserName          string
	UserActive        bool
	PermissionID      int64
	PermissionUser    int64
	PermissionAccount int64
	PermissionInteger int64
	PermissionActive  bool
}

func (q *Queries) PermissionByUserIDAndAccountID(ctx context.Context, arg PermissionByUserIDAndAccountIDParams) (PermissionByUserIDAndAccountIDRow, error) {
	row := q.db.QueryRowContext(ctx, permissionByUserIDAndAccountID, arg.UserID, arg.AccountID)
	var i PermissionByUserIDAndAccountIDRow
	err := row.Scan(
		&i.AccountID,
		&i.AccountAbbr,
		&i.AccountName,
		&i.AccountActive,
		&i.UserID,
		&i.UserEmail,
		&i.UserName,
		&i.UserActive,
		&i.PermissionID,
		&i.PermissionUser,
		&i.PermissionAccount,
		&i.PermissionInteger,
		&i.PermissionActive,
	)
	return i, err
}

const permissionsByUserID = `-- name: PermissionsByUserID :many
SELECT a.account_id, a.account_abbr, a.account_name, a.account_active, u.user_id, u.user_email, u.user_name, u.user_active, p.permission_id, p.permission_user, p.permission_account, p.permission_integer, p.permission_active
FROM users       u
JOIN permissions p ON u.user_id    = p.permission_user
JOIN accounts    a ON a.account_id = p.permission_account
WHERE u.user_id = ?
`

type PermissionsByUserIDRow struct {
	AccountID         int64
	AccountAbbr       string
	AccountName       string
	AccountActive     bool
	UserID            int64
	UserEmail         string
	UserName          string
	UserActive        bool
	PermissionID      int64
	PermissionUser    int64
	PermissionAccount int64
	PermissionInteger int64
	PermissionActive  bool
}

func (q *Queries) PermissionsByUserID(ctx context.Context, userID int64) ([]PermissionsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, permissionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PermissionsByUserIDRow
	for rows.Next() {
		var i PermissionsByUserIDRow
		if err := rows.Scan(
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.UserActive,
			&i.PermissionID,
			&i.PermissionUser,
			&i.PermissionAccount,
			&i.PermissionInteger,
			&i.PermissionActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const purchaseSubscriptionByRequestIDAndAccountID = `-- name: PurchaseSubscriptionByRequestIDAndAccountID :one
SELECT DISTINCT subscription_id, subscription_purchase, subscription_user, subscription_dist, subscription_issued, subscription_gross_amount, subscription_signature, subscription_signed, subscription_active, purchase_id, purchase_request, purchase_required, purchase_supplier, purchase_currency, purchase_ex_rate_colones, purchase_gross_amount, purchase_discount, purchase_tax_rate, purchase_geco_sol, purchase_geco_ord, purchase_bill, purchase_transfer, purchase_status, user_id, user_email, user_name, user_active, dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active, req_id, req_user, req_account, req_issued, req_descr, req_justif, entry_id, entry_year, entry_code, entry_object, entry_amount, account_id, account_abbr, account_name, account_active, period_id, period_name, period_start, period_end, period_active, supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location
FROM full_purchase_subscriptions
WHERE req_id = ?
AND account_id = ?
`

type PurchaseSubscriptionByRequestIDAndAccountIDParams struct {
	ReqID     int64
	AccountID int64
}

func (q *Queries) PurchaseSubscriptionByRequestIDAndAccountID(ctx context.Context, arg PurchaseSubscriptionByRequestIDAndAccountIDParams) (FullPurchaseSubscription, error) {
	row := q.db.QueryRowContext(ctx, purchaseSubscriptionByRequestIDAndAccountID, arg.ReqID, arg.AccountID)
	var i FullPurchaseSubscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.SubscriptionPurchase,
		&i.SubscriptionUser,
		&i.SubscriptionDist,
		&i.SubscriptionIssued,
		&i.SubscriptionGrossAmount,
		&i.SubscriptionSignature,
		&i.SubscriptionSigned,
		&i.SubscriptionActive,
		&i.PurchaseID,
		&i.PurchaseRequest,
		&i.PurchaseRequired,
		&i.PurchaseSupplier,
		&i.PurchaseCurrency,
		&i.PurchaseExRateColones,
		&i.PurchaseGrossAmount,
		&i.PurchaseDiscount,
		&i.PurchaseTaxRate,
		&i.PurchaseGecoSol,
		&i.PurchaseGecoOrd,
		&i.PurchaseBill,
		&i.PurchaseTransfer,
		&i.PurchaseStatus,
		&i.UserID,
		&i.UserEmail,
		&i.UserName,
		&i.UserActive,
		&i.DistID,
		&i.DistPeriod,
		&i.DistEntryCode,
		&i.DistAccount,
		&i.DistAmount,
		&i.DistActive,
		&i.ReqID,
		&i.ReqUser,
		&i.ReqAccount,
		&i.ReqIssued,
		&i.ReqDescr,
		&i.ReqJustif,
		&i.EntryID,
		&i.EntryYear,
		&i.EntryCode,
		&i.EntryObject,
		&i.EntryAmount,
		&i.AccountID,
		&i.AccountAbbr,
		&i.AccountName,
		&i.AccountActive,
		&i.PeriodID,
		&i.PeriodName,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.PeriodActive,
		&i.SupplierID,
		&i.SupplierName,
		&i.SupplierEmail,
		&i.SupplierPhoneCountryCode,
		&i.SupplierPhone,
		&i.SupplierLocation,
	)
	return i, err
}

const purchaseSubscriptionsByRequestID = `-- name: PurchaseSubscriptionsByRequestID :many
SELECT DISTINCT subscription_id, subscription_purchase, subscription_user, subscription_dist, subscription_issued, subscription_gross_amount, subscription_signature, subscription_signed, subscription_active, purchase_id, purchase_request, purchase_required, purchase_supplier, purchase_currency, purchase_ex_rate_colones, purchase_gross_amount, purchase_discount, purchase_tax_rate, purchase_geco_sol, purchase_geco_ord, purchase_bill, purchase_transfer, purchase_status, user_id, user_email, user_name, user_active, dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active, req_id, req_user, req_account, req_issued, req_descr, req_justif, entry_id, entry_year, entry_code, entry_object, entry_amount, account_id, account_abbr, account_name, account_active, period_id, period_name, period_start, period_end, period_active, supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location
FROM full_purchase_subscriptions
WHERE req_id = ?
`

func (q *Queries) PurchaseSubscriptionsByRequestID(ctx context.Context, reqID int64) ([]FullPurchaseSubscription, error) {
	rows, err := q.db.QueryContext(ctx, purchaseSubscriptionsByRequestID, reqID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullPurchaseSubscription
	for rows.Next() {
		var i FullPurchaseSubscription
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.SubscriptionPurchase,
			&i.SubscriptionUser,
			&i.SubscriptionDist,
			&i.SubscriptionIssued,
			&i.SubscriptionGrossAmount,
			&i.SubscriptionSignature,
			&i.SubscriptionSigned,
			&i.SubscriptionActive,
			&i.PurchaseID,
			&i.PurchaseRequest,
			&i.PurchaseRequired,
			&i.PurchaseSupplier,
			&i.PurchaseCurrency,
			&i.PurchaseExRateColones,
			&i.PurchaseGrossAmount,
			&i.PurchaseDiscount,
			&i.PurchaseTaxRate,
			&i.PurchaseGecoSol,
			&i.PurchaseGecoOrd,
			&i.PurchaseBill,
			&i.PurchaseTransfer,
			&i.PurchaseStatus,
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.UserActive,
			&i.DistID,
			&i.DistPeriod,
			&i.DistEntryCode,
			&i.DistAccount,
			&i.DistAmount,
			&i.DistActive,
			&i.ReqID,
			&i.ReqUser,
			&i.ReqAccount,
			&i.ReqIssued,
			&i.ReqDescr,
			&i.ReqJustif,
			&i.EntryID,
			&i.EntryYear,
			&i.EntryCode,
			&i.EntryObject,
			&i.EntryAmount,
			&i.AccountID,
			&i.AccountAbbr,
			&i.AccountName,
			&i.AccountActive,
			&i.PeriodID,
			&i.PeriodName,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.PeriodActive,
			&i.SupplierID,
			&i.SupplierName,
			&i.SupplierEmail,
			&i.SupplierPhoneCountryCode,
			&i.SupplierPhone,
			&i.SupplierLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const requestByID = `-- name: RequestByID :one
SELECT req_id, req_user, req_account, req_issued, req_descr, req_justif FROM requests
WHERE req_id = ?
`

func (q *Queries) RequestByID(ctx context.Context, reqID int64) (Request, error) {
	row := q.db.QueryRowContext(ctx, requestByID, reqID)
	var i Request
	err := row.Scan(
		&i.ReqID,
		&i.ReqUser,
		&i.ReqAccount,
		&i.ReqIssued,
		&i.ReqDescr,
		&i.ReqJustif,
	)
	return i, err
}

const requestsByAccountID = `-- name: RequestsByAccountID :many
SELECT req_id, req_user, req_account, req_issued, req_descr, req_justif FROM requests
WHERE req_account = ?
`

func (q *Queries) RequestsByAccountID(ctx context.Context, reqAccount int64) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, requestsByAccountID, reqAccount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ReqID,
			&i.ReqUser,
			&i.ReqAccount,
			&i.ReqIssued,
			&i.ReqDescr,
			&i.ReqJustif,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const supplierByCatalogGrouping = `-- name: SupplierByCatalogGrouping :one
SELECT
  s.supplier_id, s.supplier_name, s.supplier_email, s.supplier_phone_country_code, s.supplier_phone, s.supplier_location
FROM catalogs AS c
JOIN suppliers AS s
  ON s.supplier_id = c.catalog_supplier
WHERE c.catalog_grouping = ?
LIMIT 1
`

func (q *Queries) SupplierByCatalogGrouping(ctx context.Context, catalogGrouping int64) (Supplier, error) {
	row := q.db.QueryRowContext(ctx, supplierByCatalogGrouping, catalogGrouping)
	var i Supplier
	err := row.Scan(
		&i.SupplierID,
		&i.SupplierName,
		&i.SupplierEmail,
		&i.SupplierPhoneCountryCode,
		&i.SupplierPhone,
		&i.SupplierLocation,
	)
	return i, err
}

const supplierByName = `-- name: SupplierByName :one
SELECT supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location FROM suppliers
WHERE supplier_name = ?
LIMIT 1
`

func (q *Queries) SupplierByName(ctx context.Context, supplierName string) (Supplier, error) {
	row := q.db.QueryRowContext(ctx, supplierByName, supplierName)
	var i Supplier
	err := row.Scan(
		&i.SupplierID,
		&i.SupplierName,
		&i.SupplierEmail,
		&i.SupplierPhoneCountryCode,
		&i.SupplierPhone,
		&i.SupplierLocation,
	)
	return i, err
}

const supplierEmails = `-- name: SupplierEmails :many
SELECT supplier_email FROM suppliers
`

func (q *Queries) SupplierEmails(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, supplierEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var supplier_email string
		if err := rows.Scan(&supplier_email); err != nil {
			return nil, err
		}
		items = append(items, supplier_email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleAccountActiveByAccountID = `-- name: ToggleAccountActiveByAccountID :exec
UPDATE accounts
SET account_active = NOT account_active
WHERE account_id = ?
`

func (q *Queries) ToggleAccountActiveByAccountID(ctx context.Context, accountID int64) error {
	_, err := q.db.ExecContext(ctx, toggleAccountActiveByAccountID, accountID)
	return err
}

const toggleDistributionActiveByDistributionID = `-- name: ToggleDistributionActiveByDistributionID :exec
UPDATE distributions
SET dist_active = NOT dist_active
WHERE dist_id = ?
`

func (q *Queries) ToggleDistributionActiveByDistributionID(ctx context.Context, distID int64) error {
	_, err := q.db.ExecContext(ctx, toggleDistributionActiveByDistributionID, distID)
	return err
}

const togglePeriodActiveByPeriodID = `-- name: TogglePeriodActiveByPeriodID :exec
UPDATE periods
SET period_active = NOT period_active
WHERE period_id = ?
`

func (q *Queries) TogglePeriodActiveByPeriodID(ctx context.Context, periodID int64) error {
	_, err := q.db.ExecContext(ctx, togglePeriodActiveByPeriodID, periodID)
	return err
}

const togglePermissionByPermissionID = `-- name: TogglePermissionByPermissionID :exec
UPDATE permissions
SET permission_integer = ?
WHERE permission_id = ?
`

type TogglePermissionByPermissionIDParams struct {
	PermissionInteger int64
	PermissionID      int64
}

func (q *Queries) TogglePermissionByPermissionID(ctx context.Context, arg TogglePermissionByPermissionIDParams) error {
	_, err := q.db.ExecContext(ctx, togglePermissionByPermissionID, arg.PermissionInteger, arg.PermissionID)
	return err
}

const toggleSubscriptionActiveByID = `-- name: ToggleSubscriptionActiveByID :exec
UPDATE purchase_subscriptions
SET subscription_active = NOT subscription_active
WHERE subscription_id = ?
`

func (q *Queries) ToggleSubscriptionActiveByID(ctx context.Context, subscriptionID int64) error {
	_, err := q.db.ExecContext(ctx, toggleSubscriptionActiveByID, subscriptionID)
	return err
}

const toggleUserActiveByUserID = `-- name: ToggleUserActiveByUserID :exec
UPDATE users
SET user_active = NOT user_active
WHERE user_id = ?
`

func (q *Queries) ToggleUserActiveByUserID(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, toggleUserActiveByUserID, userID)
	return err
}

const updateDistribution = `-- name: UpdateDistribution :one
UPDATE distributions SET
    dist_amount = ?
WHERE dist_id = ? RETURNING dist_id, dist_period, dist_entry_code, dist_account, dist_amount, dist_active
`

type UpdateDistributionParams struct {
	DistAmount float64
	DistID     int64
}

func (q *Queries) UpdateDistribution(ctx context.Context, arg UpdateDistributionParams) (Distribution, error) {
	row := q.db.QueryRowContext(ctx, updateDistribution, arg.DistAmount, arg.DistID)
	var i Distribution
	err := row.Scan(
		&i.DistID,
		&i.DistPeriod,
		&i.DistEntryCode,
		&i.DistAccount,
		&i.DistAmount,
		&i.DistActive,
	)
	return i, err
}

const updateItem = `-- name: UpdateItem :one
UPDATE items SET
    item_number = ?,
    item_summary = ?,
    item_description = ?,
    item_amount = ?
WHERE item_id = ? RETURNING item_id, item_catalog, item_number, item_summary, item_description, item_amount
`

type UpdateItemParams struct {
	ItemNumber      int64
	ItemSummary     string
	ItemDescription string
	ItemAmount      float64
	ItemID          int64
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, updateItem,
		arg.ItemNumber,
		arg.ItemSummary,
		arg.ItemDescription,
		arg.ItemAmount,
		arg.ItemID,
	)
	var i Item
	err := row.Scan(
		&i.ItemID,
		&i.ItemCatalog,
		&i.ItemNumber,
		&i.ItemSummary,
		&i.ItemDescription,
		&i.ItemAmount,
	)
	return i, err
}

const updatePeriod = `-- name: UpdatePeriod :one
UPDATE periods SET
    period_name = ?,
    period_start = ?,
    period_end = ?
WHERE period_id = ? RETURNING period_id, period_name, period_start, period_end, period_active
`

type UpdatePeriodParams struct {
	PeriodName  string
	PeriodStart int64
	PeriodEnd   int64
	PeriodID    int64
}

func (q *Queries) UpdatePeriod(ctx context.Context, arg UpdatePeriodParams) (Period, error) {
	row := q.db.QueryRowContext(ctx, updatePeriod,
		arg.PeriodName,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.PeriodID,
	)
	var i Period
	err := row.Scan(
		&i.PeriodID,
		&i.PeriodName,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.PeriodActive,
	)
	return i, err
}

const updatePurchaseSubscription = `-- name: UpdatePurchaseSubscription :one
UPDATE purchase_subscriptions
SET subscription_gross_amount = ?,
    subscription_signed = ?,
    subscription_signature = ?,
    subscription_active = ?
WHERE subscription_id = ?
RETURNING subscription_id, subscription_purchase, subscription_user, subscription_dist, subscription_issued, subscription_gross_amount, subscription_signature, subscription_signed, subscription_active
`

type UpdatePurchaseSubscriptionParams struct {
	SubscriptionGrossAmount float64
	SubscriptionSigned      bool
	SubscriptionSignature   string
	SubscriptionActive      bool
	SubscriptionID          int64
}

func (q *Queries) UpdatePurchaseSubscription(ctx context.Context, arg UpdatePurchaseSubscriptionParams) (PurchaseSubscription, error) {
	row := q.db.QueryRowContext(ctx, updatePurchaseSubscription,
		arg.SubscriptionGrossAmount,
		arg.SubscriptionSigned,
		arg.SubscriptionSignature,
		arg.SubscriptionActive,
		arg.SubscriptionID,
	)
	var i PurchaseSubscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.SubscriptionPurchase,
		&i.SubscriptionUser,
		&i.SubscriptionDist,
		&i.SubscriptionIssued,
		&i.SubscriptionGrossAmount,
		&i.SubscriptionSignature,
		&i.SubscriptionSigned,
		&i.SubscriptionActive,
	)
	return i, err
}

const updateSupplier = `-- name: UpdateSupplier :one
UPDATE suppliers SET
    supplier_name = ?,
    supplier_email = ?,
    supplier_phone_country_code = ?,
    supplier_phone = ?,
    supplier_location = ?
WHERE supplier_id = ? RETURNING supplier_id, supplier_name, supplier_email, supplier_phone_country_code, supplier_phone, supplier_location
`

type UpdateSupplierParams struct {
	SupplierName             string
	SupplierEmail            string
	SupplierPhoneCountryCode int64
	SupplierPhone            int64
	SupplierLocation         string
	SupplierID               int64
}

func (q *Queries) UpdateSupplier(ctx context.Context, arg UpdateSupplierParams) (Supplier, error) {
	row := q.db.QueryRowContext(ctx, updateSupplier,
		arg.SupplierName,
		arg.SupplierEmail,
		arg.SupplierPhoneCountryCode,
		arg.SupplierPhone,
		arg.SupplierLocation,
		arg.SupplierID,
	)
	var i Supplier
	err := row.Scan(
		&i.SupplierID,
		&i.SupplierName,
		&i.SupplierEmail,
		&i.SupplierPhoneCountryCode,
		&i.SupplierPhone,
		&i.SupplierLocation,
	)
	return i, err
}

const userByID = `-- name: UserByID :one
SELECT user_id, user_email, user_name, user_active FROM users
WHERE user_id = ? LIMIT 1
`

func (q *Queries) UserByID(ctx context.Context, userID int64) (User, error) {
	row := q.db.QueryRowContext(ctx, userByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserName,
		&i.UserActive,
	)
	return i, err
}

const userIDByUserEmail = `-- name: UserIDByUserEmail :one
SELECT user_id FROM users
WHERE user_email = ? LIMIT 1
`

func (q *Queries) UserIDByUserEmail(ctx context.Context, userEmail string) (int64, error) {
	row := q.db.QueryRowContext(ctx, userIDByUserEmail, userEmail)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}
